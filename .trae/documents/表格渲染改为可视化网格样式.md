## 目标
- 将 Markdown 表格从“字符拼表格（ASCII/等宽）”升级为“可视化表格”（带边框、表头底色、单元格内边距），避免因字体/全角字符导致错位。
- 在 Canvas 渲染、SVG 导出、文本测量、受限宽度换行四条链路保持一致。

## 设计取舍
- 继续把表格作为“文本元素的一种块级渲染”，不新增 `table` 元素类型（当前元素类型里没有原生 table）。
- 表格布局不依赖字符宽度；所有列宽/行高都用现有测量能力（`getLineWidth/measureText`）按像素计算。

## 实现步骤
1. **解析层（common）**
   - 在 `parseMarkdownToLines()` 之外新增结构化产物：识别 Markdown pipe table 与 HTML `<table>`，输出 `MarkdownTable`（rows/cols/cellText/align/headerRowIndex）。
   - 保持现有 `parseInlineMarkdown()` 用于单元格内联样式。

2. **布局层（element）**
   - 新增表格布局函数：
     - 计算每列像素宽度（按内容最大值 + padding），支持对齐（左/中/右）。
     - 在受限宽度（容器或手动改宽）下，按列分配宽度并对单元格内容做换行/截断（优先换行，必要时截断）。
     - 计算每行高度（取该行各单元格换行后的最大高度）。

3. **Canvas 渲染（element/renderElement.ts）**
   - 在文本渲染分支中检测 table block：
     - 画表格外框与网格线（strokeColor/opacity 继承文本颜色或使用固定浅色）。
     - 表头行绘制浅灰背景。
     - 单元格文字按对齐与 padding 绘制（继续复用现有 Markdown runs 分段绘制）。

4. **SVG 导出（excalidraw/renderer/staticSvgScene.ts）**
   - 生成 `<rect>`（表头底色、边框）与 `<text>/<tspan>`（单元格文字），保证与 Canvas 同布局。

5. **测量与换行（element/textMeasurements.ts + element/textWrapping.ts）**
   - `getTextWidth/getTextHeight`：遇到表格块使用表格布局结果计算整体宽高。
   - `wrapText`：检测表格块时不再把表格当普通文本逐行 wrap，而是走“表格布局（分配列宽→单元格 wrap）”。

6. **测试**
   - common：表格解析为结构化模型（包含对齐、表头识别）。
   - element：受限宽度下表格不溢出、不错位（断言列宽/总宽与行数）。
   - excalidraw：SVG 导出中存在表格网格与表头背景（快照或结构断言）。

## 交付效果（与截图一致）
- 表头灰底 + 粗体；单元格有 padding；行列边框清晰；窄宽度下单元格内容自动换行，表格整体不溢出。

如果确认采用该样式，我将按以上步骤落地到代码中，并保持旧的“字符表格”作为可选降级路径（用于极端环境或性能回退）。